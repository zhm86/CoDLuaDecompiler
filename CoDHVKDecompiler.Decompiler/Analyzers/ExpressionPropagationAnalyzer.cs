using System;
using System.Collections.Generic;
using System.Linq;
using CoDHVKDecompiler.Decompiler.CFG;
using CoDHVKDecompiler.Decompiler.IR.Expression;
using CoDHVKDecompiler.Decompiler.IR.Functions;
using CoDHVKDecompiler.Decompiler.IR.Identifiers;
using CoDHVKDecompiler.Decompiler.IR.Instruction;
using ValueType = CoDHVKDecompiler.Decompiler.IR.Identifiers.ValueType;

namespace CoDHVKDecompiler.Decompiler.Analyzers
{
    /// <summary>
    /// Given the IR is in SSA form, this does expression propagation/substitution
    /// </summary>
    public class ExpressionPropagationAnalyzer : IAnalyzer
    {
        public void Analyze(Function f)
        {
            // Lua, with its simple one-pass compiler, doesn't really have a register allocation algorithm of any kind. Local variables are allocated to
            // a single register for the lifetime of the entire scope, while temp locals generated by the compiler for complex expressions only have a
            // lifetime for that expression (i.e. once the expression is done evaluating, that register is free to be used in that scope again. Of course,
            // we can exploit this to figure out local variables in the original source code even if they only had one use: If the next register defined
            // within the scope (dominance hierarchy) after the first use of a recently defined register is not that register, then it's likely an actual
            // local variable.
            HashSet<Identifier> definitelyLocal = new HashSet<Identifier>();
            int LocalIdentifyVisit(BasicBlock b, HashSet<Identifier> localRegs)
            {
                HashSet<Identifier> thisLocalRegs = new HashSet<Identifier>();
                thisLocalRegs.UnionWith(localRegs);

                // Set of recently used registers that are candidates for locals
                Dictionary<Identifier, Identifier> recentlyUsed = new Dictionary<Identifier, Identifier>();
                for (int i = 0; i < b.Instructions.Count(); i++)
                {
                    // First add registers such the set contains all the registers used up to this point
                    foreach (var use in b.Instructions[i].GetUses(true))
                    {
                        if (thisLocalRegs.Contains(use.OriginalIdentifier))
                        {
                            // Already marked as a local
                            continue;
                        }

                        if (recentlyUsed.Count > 0)
                        {
                            if (!recentlyUsed.ContainsKey(use.OriginalIdentifier))
                            {
                                recentlyUsed.Add(use.OriginalIdentifier, use);
                            }
                            else
                            {
                                // Double use. Definitely a local
                                definitelyLocal.Add(use);
                                thisLocalRegs.Add(use.OriginalIdentifier);
                                recentlyUsed.Remove(use.OriginalIdentifier);
                            }
                        }
                    }

                    bool removed = false;

                    var defines = b.Instructions[i].GetDefines(true);

                    // If this is a multiassignment then these variables are almost certainly locals
                    if (defines.Count > 1 && !(b.Instructions[i] is Assignment {Right: Constant c} && (c.Type == ValueType.Nil || c.Type == ValueType.Boolean)))
                    {
                        foreach (var def in defines)
                        {
                            // Unfortunately this pretty much kills any previous def of this in scope's chances to actually be a local
                            if (recentlyUsed.ContainsKey(def.OriginalIdentifier))
                            {
                                recentlyUsed.Remove(def.OriginalIdentifier);
                            }
                            definitelyLocal.Add(def);
                            thisLocalRegs.Add(def.OriginalIdentifier);
                        }
                    }
                    // This is more interesting
                    else if (defines.Count == 1)
                    {
                        // Self instructions have a lot of information because they always use the next available temp registers. This
                        // means that any pending uses below us that haven't been redefined yet are actually locals. Note that the SELF
                        // op actually translates to two IR ops with two registers used, so we account for that
                        if (b.Instructions[i] is Assignment self && self.IsSelfAssignment)
                        {
                            var def1 = defines.First();
                            var def2 = b.Instructions[i + 1].GetDefines(true); // Second instruction

                            foreach (var k in recentlyUsed.Keys)
                            {
                                // If the reg number is less than the second define then it's a local
                                if (def2.Count > 0 && k.RegNum < def2.First().OriginalIdentifier.RegNum)
                                {
                                    definitelyLocal.Add(recentlyUsed[k]);
                                    thisLocalRegs.Add(k);
                                }
                            }
                            recentlyUsed.Clear();
                            i++;
                            continue;
                        }

                        var def = defines.First();
                        
                        // Skip upvalue
                        if (def.IsClosureBound/* || def.Renamed*/)
                        {
                            continue;
                        }
                        
                        // Move on if it's a known local
                        if (thisLocalRegs.Contains(def.OriginalIdentifier))
                        {
                            continue;
                        }

                        // Otherwise a quick redefine is likely a temp. Mark below as locals and above as temps
                        if (recentlyUsed.ContainsKey(def.OriginalIdentifier))
                        {
                            foreach (var k in recentlyUsed.Keys)
                            {
                                // If the reg number is less than the second define then it's a local
                                if (k.RegNum < def.OriginalIdentifier.RegNum)
                                {
                                    definitelyLocal.Add(recentlyUsed[k]);
                                    thisLocalRegs.Add(k);
                                }
                            }
                            recentlyUsed.Clear();
                            continue;
                        }

                        // We're now seeing a new register defined. Anything left in recently used is probably a local
                        /*foreach (var ru in recentlyUsed)
                        {
                            definitelyLocal.Add()
                        }*/
                    }
                }

                // Visit next blocks in scope
                var childFirstDef = int.MaxValue;
                foreach (var succ in b.DominanceTreeSuccessors)
                {
                    var fd = LocalIdentifyVisit(succ, thisLocalRegs);
                    if (fd < childFirstDef && fd != -1)
                    {
                        childFirstDef = fd;
                    }
                }

                // Localize remaining identifiers with reg numbers below the first presumed temp define in the following blocks in scope
                if (childFirstDef != -1 && childFirstDef != int.MaxValue)
                {
                    foreach (var k in recentlyUsed.Keys)
                    {
                        // If the reg number is less than the second define then it's a local
                        if (k.RegNum < childFirstDef)
                        {
                            definitelyLocal.Add(recentlyUsed[k]);
                            thisLocalRegs.Add(k);
                        }
                    }
                }

                // Find the register of the first non-local define to return
                int firstTempDef = -1;
                foreach (var inst in b.Instructions)
                {
                    var defs = inst.GetDefines(true);
                    if (defs.Count == 1)
                    {
                        var def = defs.First();
                        if (!definitelyLocal.Contains(def) /*&& !def.Renamed*/ && !def.IsClosureBound)
                        {
                            firstTempDef = (int)def.OriginalIdentifier.RegNum;
                            if (inst is Assignment self && self.IsSelfAssignment)
                            {
                                // Again a SELF op generates two assignments-the second one being the lower reg number
                                firstTempDef--;
                            }
                            break;
                        }
                    }
                }
                return firstTempDef;
            }
            LocalIdentifyVisit(f.StartBlock, new HashSet<Identifier>(f.Parameters));
            
            bool changed;
            do
            {
                changed = false;
                foreach (var b in f.Blocks)
                {
                    for (int i = 0; i < b.Instructions.Count(); i++)
                    {
                        var inst = b.Instructions[i];
                        foreach (var use in inst.GetUses(true))
                        {
                            if (use.DefiningInstruction != null &&
                                use.DefiningInstruction is Assignment a &&
                                (a.Left.Count() == 1 || a.Left.Count > 1 && a.Right is Constant {Type: ValueType.Nil}) && !(a.Right is IdentifierReference {HasIndex: false} ir && ir.GetUses(true).Count > 1) &&
                                ((use.UseCount == 1 && ((i - 1 >= 0 && b.Instructions[i - 1] == use.DefiningInstruction) || (inst is Assignment a2 && a2.IsListAssignment)) && !definitelyLocal.Contains(use)) || a.PropagateAlways) &&
                                !a.Left[0].Identifier.IsClosureBound)
                            {
                                bool replaced = inst.ReplaceUses(use, a.Right);
                                if (a.Block != null && replaced)
                                {
                                    changed = true;
                                    if (a.Left.Count == 1)
                                        a.Block.Instructions.Remove(a);
                                    else
                                        a.Left.Remove(a.Left.Find(lir => lir.Identifier == use));
                                    f.SSAVariables.Remove(use);
                                    if (b == a.Block)
                                    {
                                        i--;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Propagate list initializers
                // local fx_localy = {}
                // local x1 = {...}
                // local x2 = {...}
                // fx_localy[1] = x1
                // fx_localy[2] = x2
                //  to
                // local fx_localy = {
                //   {...},
                //   {...}
                // }
                foreach (var b in f.Blocks)
                {
                    for (int i = 2; i < b.Instructions.Count; i++)
                    {
                        var instr = b.Instructions[i];
                        // Find the first assignment
                        if (instr is Assignment a && a.Left.Count == 1 && a.Left[0].TableIndices.Count == 1 && 
                            a.Right is IdentifierReference ir && !ir.HasIndex && a.Left[0].Identifier.DefiningInstruction is Assignment a2 && a2.Right is InitializerList  il && il.Expressions.Count == 0 &&
                            a.Left[0].TableIndices[0] is Constant c && c.Type == ValueType.Number && Math.Abs(c.Number - 1) < 0.001)
                        {
                            // Check how many there are
                            int tableLength = 0;
                            int tIndex = i;
                            while (tIndex < b.Instructions.Count && b.Instructions[tIndex] is Assignment tA && tA.Left.Count == 1 && tA.Left[0].TableIndices.Count == 1 &&
                                   tA.Right is IdentifierReference tIr && !tIr.HasIndex && tA.Left[0].Identifier == a.Left[0].Identifier &&
                                   tA.Left[0].TableIndices[0] is Constant c2 && c2.Type == ValueType.Number && Math.Abs(c2.Number - (tableLength + 1)) < 0.001
                                   )
                            {
                                tableLength++;
                                tIndex++;
                            }

                            // Make sure the defining instruction is in the right spot
                            if (!(i - tableLength - 1 >= 0 && b.Instructions[i - tableLength - 1] is Assignment a5 && a5.Left.Count == 1 && a2 == a5))
                            {
                                continue;
                            }

                            bool valid = true;
                            for (int j = 0; j < tableLength; j++)
                            {
                                if (!(b.Instructions[i + j] is Assignment a3 && a3.Right is IdentifierReference ir2 &&
                                      b.Instructions[i - tableLength + j] is Assignment a4 && a4.Left.Count == 1 &&
                                      ir2.Identifier == a4.Left[0].Identifier))
                                {
                                    valid = false;
                                }
                            }

                            if (valid)
                            {
                                for (int j = 0; j < tableLength; j++)
                                {
                                    ((Assignment) b.Instructions[i + j]).Right =
                                        ((Assignment) b.Instructions[i - tableLength + j]).Right;
                                }
                                b.Instructions.RemoveRange(i -  tableLength, tableLength);
                                changed = true;
                            }
                        }
                    }
                }

                changed = changed || PropagateFunctionCallOnSelf(f);

                // Lua might generate the following (decompiled) code when doing a this call on a global variable:
                //     REG0 = someGlobal
                //     REG0:someFunction(blah...)
                // This rewrites such statements to
                //     someGlobal:someFunction(blah...)
                foreach (var b in f.Blocks)
                {
                    for (int i = 0; i < b.Instructions.Count(); i++)
                    {
                        var inst = b.Instructions[i];
                        if (inst is Assignment a && a.Right is FunctionCall fc && fc.Arguments.Count > 0 && 
                            fc.Arguments[0] is IdentifierReference ir && !ir.HasIndex && ir.Identifier.UseCount == 2 && fc.Function.GetUses(true).Contains(ir.Identifier) &&
                            i > 0 && b.Instructions[i - 1] is Assignment a2 && a2.Left.Count == 1 && !(a2.Right is FunctionCall f2) && 
                            !a2.Left[0].HasIndex && a2.Left[0].Identifier == ir.Identifier)
                        {
                            a.ReplaceUses(a2.Left[0].Identifier, a2.Right);
                            b.Instructions.RemoveAt(i - 1);
                            i--;
                            changed = true;
                        }
                    }
                }
            } while (changed);
        }

        /// <summary>
        /// Changing the functioncall on self
        /// REG0.someFunction(REG0, ...)
        ///     to
        /// REG0:someFunction(...)
        /// </summary>
        /// <param name="f">Function to do the analysis on</param>
        /// <returns>Whether or not something has changed</returns>
        private bool PropagateFunctionCallOnSelf(Function f)
        {
            bool changed = false;
            foreach (var b in f.Blocks)
            {
                for (int i = 0; i < b.Instructions.Count(); i++)
                {
                    var expressions = b.Instructions[i].GetExpressions().Where(e => e is FunctionCall).ToList();
                    foreach (var expression in expressions)
                    {
                        if (expression is FunctionCall {Function: IdentifierReference ir} fc && ir.TableIndices.Count >= 1 && 
                            ir.TableIndices[^1] is Constant {Type: ValueType.String} && fc.Arguments.Any() && 
                            fc.Arguments[0] is IdentifierReference {HasIndex: false} argIr && 
                            (ir == argIr || ir.HasIndex && ir.Identifier == argIr.Identifier))
                        {
                            fc.Arguments.RemoveAt(0);
                            fc.IsFunctionCalledOnSelf = true;
                            if (ir.Identifier.UseCount > 1)
                                ir.Identifier.UseCount--;
                            changed = true;
                        }
                    }
                }
            }

            return changed;
        }
    }
}